---
phase: 04-git-harness-and-logging
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/agent/git-harness.ts
  - src/agent/run-logger.ts
  - src/core/config.ts
  - src/core/types.ts
  - tests/unit/git-harness.test.ts
  - tests/unit/run-logger.test.ts
autonomous: true
requirements:
  - AGENT-01
  - AGENT-02
  - LOG-01

must_haves:
  truths:
    - "cloneRepo creates a temp directory and runs git clone --depth 1 into it"
    - "cloneRepo sets GIT_CONFIG_NOSYSTEM=1 and preserves SSH_AUTH_SOCK in the clone env"
    - "cloneRepo returns both repoDir and handoffDir paths"
    - "cloneRepo cleans up both dirs on clone failure"
    - "cleanupDir removes a directory recursively and never throws"
    - "appendRunLog creates the logs directory if missing and appends one JSON line per call"
    - "appendRunLog writes the exact locked fields: date, category, mr_url, cost_usd, duration_seconds, summary"
    - "Config schema accepts optional log prompt path and optional log_mcp_config"
  artifacts:
    - path: "src/agent/git-harness.ts"
      provides: "cloneRepo and cleanupDir functions"
      exports: ["cloneRepo", "cleanupDir", "CloneResult"]
    - path: "src/agent/run-logger.ts"
      provides: "appendRunLog function and RunLogEntry interface"
      exports: ["appendRunLog", "RunLogEntry"]
    - path: "tests/unit/git-harness.test.ts"
      provides: "Unit tests for clone lifecycle and cleanup"
    - path: "tests/unit/run-logger.test.ts"
      provides: "Unit tests for JSONL append behavior"
  key_links:
    - from: "src/agent/git-harness.ts"
      to: "src/utils/process.ts"
      via: "spawnWithTimeout for git clone"
      pattern: "spawnWithTimeout.*git.*clone"
    - from: "src/agent/run-logger.ts"
      to: "src/core/paths.ts"
      via: "getLogsDir and ensureDir for log file location"
      pattern: "getLogsDir|ensureDir"
---

<objective>
Create the git clone/cleanup harness and the JSONL run logger as TDD-driven utility modules. Extend the config schema to support the new log bead.

Purpose: AGENT-01 (fresh clone per run), AGENT-02 (unconditional cleanup), and LOG-01 (local JSONL log) are foundational utilities that the top-level harness (Plan 02) depends on. The config schema must also be extended to add `log` prompt path and `log_mcp_config` for the Confluence log bead.
Output: `git-harness.ts`, `run-logger.ts`, updated `config.ts` and `types.ts`, and full test coverage.
</objective>

<execution_context>
@/Users/julienderay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julienderay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-git-harness-and-logging/04-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/utils/process.ts:
```typescript
export interface SpawnResult {
  stdout: string;
  stderr: string;
  exitCode: number | null;
  signal: NodeJS.Signals | null;
  timedOut: boolean;
}

export function spawnWithTimeout(
  command: string,
  args: string[],
  options?: {
    timeoutMs?: number;
    cwd?: string;
    env?: NodeJS.ProcessEnv;
    taskId?: string;
  },
): { process: ChildProcess; result: Promise<SpawnResult> };
```

From src/core/paths.ts:
```typescript
export function getLogsDir(base?: string): string;
export async function ensureDir(dirPath: string): Promise<void>;
```

From src/core/types.ts (CodeAgentConfig — to be extended):
```typescript
export interface CodeAgentConfig {
  repoUrl: string;
  confluencePageId: string;
  categorySchedule: CategoryScheduleConfig;
  prompts: {
    analyze: string;
    implement: string;
    verify: string;
    mr: string;
  };
  reviewer?: string;
  allowedCommands: string[];
  maxTokens?: number;
  variables: Record<string, string>;
}
```

From src/core/config.ts (CodeAgentSchema — to be extended):
```typescript
const CodeAgentSchema = z.object({
  // ... existing fields ...
  prompts: z.object({
    analyze: z.string().default("./prompts/analyze.md"),
    implement: z.string().default("./prompts/implement.md"),
    verify: z.string().default("./prompts/verify.md"),
    mr: z.string().default("./prompts/mr.md"),
  }).default(() => ({ /* ... */ })),
}).optional();
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD git-harness — cloneRepo and cleanupDir</name>
  <files>
    src/agent/git-harness.ts
    tests/unit/git-harness.test.ts
  </files>
  <action>
**RED phase — write failing tests first in `tests/unit/git-harness.test.ts`:**

Mock `node:fs/promises` (mkdtemp, rm), `node:os` (tmpdir), and `../../src/utils/process.js` (spawnWithTimeout). Import `cloneRepo` and `cleanupDir` from `../../src/agent/git-harness.js`.

Test cases for `cloneRepo`:
1. Creates two temp dirs via `fs.mkdtemp` with `night-shift-repo-` and `night-shift-handoff-` prefixes under `os.tmpdir()`
2. Calls `spawnWithTimeout("git", ["clone", "--depth", "1", repoUrl, repoDir], { env })` where env contains `HOME`, `PATH`, `SSH_AUTH_SOCK`, `GIT_CONFIG_NOSYSTEM: "1"`, and `GITLAB_TOKEN` when provided
3. Returns `{ repoDir, handoffDir }` on success (exitCode 0)
4. On clone failure (exitCode 128), calls `fs.rm` on both dirs and throws an error containing "git clone failed"
5. When `gitlabToken` is undefined, env does NOT contain `GITLAB_TOKEN`
6. When `gitlabToken` is provided, env contains `GITLAB_TOKEN` with the token value

Test cases for `cleanupDir`:
7. Calls `fs.rm(dirPath, { recursive: true, force: true })`
8. Does NOT throw even when `fs.rm` rejects (swallows errors)

Run tests to confirm RED (all fail).

**GREEN phase — implement in `src/agent/git-harness.ts`:**

```typescript
import fs from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import { spawnWithTimeout } from "../utils/process.js";

export interface CloneResult {
  repoDir: string;
  handoffDir: string;
}

export async function cloneRepo(
  repoUrl: string,
  gitlabToken: string | undefined,
): Promise<CloneResult> {
  const runId = Date.now().toString(36);
  const repoDir = await fs.mkdtemp(path.join(os.tmpdir(), `night-shift-repo-${runId}-`));
  const handoffDir = await fs.mkdtemp(path.join(os.tmpdir(), `night-shift-handoff-${runId}-`));

  const cloneEnv: NodeJS.ProcessEnv = {
    HOME: process.env.HOME,
    PATH: process.env.PATH,
    SSH_AUTH_SOCK: process.env.SSH_AUTH_SOCK,
    GIT_CONFIG_NOSYSTEM: "1",
    ...(gitlabToken ? { GITLAB_TOKEN: gitlabToken } : {}),
  };

  const { result } = spawnWithTimeout(
    "git",
    ["clone", "--depth", "1", repoUrl, repoDir],
    { env: cloneEnv },
  );

  const cloneResult = await result;
  if (cloneResult.exitCode !== 0) {
    await cleanupDir(repoDir);
    await cleanupDir(handoffDir);
    throw new Error(`git clone failed (exit ${cloneResult.exitCode}): ${cloneResult.stderr}`);
  }

  return { repoDir, handoffDir };
}

export async function cleanupDir(dirPath: string): Promise<void> {
  try {
    await fs.rm(dirPath, { recursive: true, force: true });
  } catch {
    // Swallow — cleanup must not propagate and mask the original error
  }
}
```

Run tests to confirm GREEN (all pass).

Commit RED: `test(04-01): add failing tests for git-harness cloneRepo and cleanupDir`
Commit GREEN: `feat(04-01): implement git-harness with clone lifecycle and unconditional cleanup`
  </action>
  <verify>
    <automated>npx vitest run tests/unit/git-harness.test.ts</automated>
  </verify>
  <done>
    cloneRepo creates temp dirs, runs shallow clone with GIT_CONFIG_NOSYSTEM=1, preserves SSH_AUTH_SOCK, returns paths on success, cleans up and throws on failure. cleanupDir is idempotent and never throws. All 8 tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD run-logger + config schema extension</name>
  <files>
    src/agent/run-logger.ts
    tests/unit/run-logger.test.ts
    src/core/config.ts
    src/core/types.ts
  </files>
  <action>
**RED phase — write failing tests first in `tests/unit/run-logger.test.ts`:**

Mock `node:fs/promises` (appendFile, mkdir) and `../../src/core/paths.js` (getLogsDir, ensureDir). Import `appendRunLog` and `RunLogEntry` from `../../src/agent/run-logger.js`.

Test cases for `appendRunLog`:
1. Calls `ensureDir` with the logs directory before writing
2. Calls `fs.appendFile` with path ending in `code-agent-runs.jsonl`
3. Written content is a single JSON line terminated with `\n`
4. JSON line contains exactly: `date`, `category`, `mr_url`, `cost_usd`, `duration_seconds`, `summary`
5. `mr_url` is `null` (literal JSON null) when entry has `null` for mr_url
6. Multiple calls append multiple lines (not overwrite)
7. Uses "utf-8" encoding

Run tests to confirm RED (all fail).

**GREEN phase — implement in `src/agent/run-logger.ts`:**

```typescript
import fs from "node:fs/promises";
import path from "node:path";
import { getLogsDir, ensureDir } from "../core/paths.js";

export interface RunLogEntry {
  date: string;
  category: string;
  mr_url: string | null;
  cost_usd: number;
  duration_seconds: number;
  summary: string;
}

export async function appendRunLog(
  entry: RunLogEntry,
  base: string = process.cwd(),
): Promise<void> {
  const logsDir = getLogsDir(base);
  await ensureDir(logsDir);
  const logPath = path.join(logsDir, "code-agent-runs.jsonl");
  await fs.appendFile(logPath, JSON.stringify(entry) + "\n", "utf-8");
}
```

Run tests to confirm GREEN (all pass).

Commit RED: `test(04-01): add failing tests for run-logger JSONL append`
Commit GREEN: `feat(04-01): implement run-logger with JSONL append`

**Config schema extension (non-TDD — config tests already exist):**

In `src/core/config.ts`, extend `CodeAgentSchema`:
1. Add `log` to the `prompts` object: `log: z.string().default("./prompts/log.md")`
2. Update the `.default(() => ({ ... }))` factory to include `log: "./prompts/log.md"`
3. Add `log_mcp_config: z.string().optional()` as a new field on `CodeAgentSchema`

In `src/core/types.ts`, extend `CodeAgentConfig`:
1. Add `log: string` to the `prompts` object type
2. Add `logMcpConfig?: string` to `CodeAgentConfig`

In `src/core/config.ts`, update `mapConfig`:
1. Map `raw.code_agent.prompts` to include `log: raw.code_agent.prompts.log`
2. Map `raw.code_agent.log_mcp_config` to `logMcpConfig: raw.code_agent.log_mcp_config`

In `src/core/config.ts`, update `getDefaultConfigYaml`:
1. Add `#   log: ./prompts/log.md` in the commented prompts block
2. Add `#   log_mcp_config: /path/to/mcp-config.json` as a new commented field

Verify existing config tests still pass, then commit: `feat(04-01): extend config schema with log prompt path and log_mcp_config`
  </action>
  <verify>
    <automated>npx vitest run tests/unit/run-logger.test.ts tests/unit/config.test.ts</automated>
  </verify>
  <done>
    appendRunLog creates logs dir and appends one JSON line per call with the exact locked fields. Config schema accepts `prompts.log` with default "./prompts/log.md" and optional `log_mcp_config`. All run-logger tests and existing config tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run tests/unit/git-harness.test.ts` — all tests pass
2. `npx vitest run tests/unit/run-logger.test.ts` — all tests pass
3. `npx vitest run tests/unit/config.test.ts` — existing + new tests pass
4. `npx tsc --noEmit` — no TypeScript compilation errors
</verification>

<success_criteria>
- git-harness.ts exports cloneRepo and cleanupDir with full test coverage
- run-logger.ts exports appendRunLog and RunLogEntry with full test coverage
- Config schema extended with log prompt path and log_mcp_config field
- All existing tests continue to pass
- Zero new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/04-git-harness-and-logging/04-01-SUMMARY.md`
</output>
