---
phase: 02-orchestrator-hooks
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/daemon/orchestrator.ts
  - tests/unit/orchestrator.test.ts
autonomous: true
requirements: [NTFY-03, NTFY-04, NTFY-05]

must_haves:
  truths:
    - "A notification fires when the daemon dispatches a task with notify: true"
    - "No notification fires when task has notify: false or ntfy is not configured"
    - "Success notification includes task name, cost, and summary with priority 3"
    - "Failure notification includes task name, error snippet, and uses priority 4"
    - "Notification send never blocks the poll loop or throws"
  artifacts:
    - path: "src/daemon/orchestrator.ts"
      provides: "NtfyClient instantiation and notifyTaskStart/notifyTaskEnd helpers"
      contains: "notifyTaskStart"
    - path: "tests/unit/orchestrator.test.ts"
      provides: "Unit tests for notification hook behaviors"
      contains: "notifyTaskStart"
  key_links:
    - from: "src/daemon/orchestrator.ts"
      to: "src/notifications/ntfy-client.ts"
      via: "NtfyClient instantiation in start() and send() calls in helpers"
      pattern: "new NtfyClient"
    - from: "src/daemon/orchestrator.ts"
      to: "src/core/types.ts"
      via: "task.notify and task.category fields checked in helpers"
      pattern: "task\\.notify"
---

<objective>
Wire NtfyClient into the Orchestrator with guard-and-delegate notification helpers that fire on task dispatch (start) and task completion (end), with distinct messages and priorities for success vs failure.

Purpose: This is the core Phase 2 deliverable -- making the daemon notify the user's phone when tasks start and finish. The notification helpers check both that ntfy is configured AND that the individual task opted in via `notify: true`, ensuring zero impact on tasks that don't use notifications.

Output: NtfyClient integration in orchestrator, notifyTaskStart/notifyTaskEnd helpers, and unit tests proving all guard conditions and message formatting.
</objective>

<execution_context>
@/Users/julienderay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julienderay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-orchestrator-hooks/02-RESEARCH.md
@.planning/phases/02-orchestrator-hooks/02-01-SUMMARY.md
@src/daemon/orchestrator.ts
@src/notifications/ntfy-client.ts
@tests/unit/orchestrator.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Add failing tests for orchestrator notification hooks</name>
  <files>tests/unit/orchestrator.test.ts</files>
  <action>
Add a new top-level `describe("Orchestrator notification hooks")` block in `tests/unit/orchestrator.test.ts`. Since the Orchestrator class is tightly coupled to its `start()` method (loads config, creates pool, writes PID), test the notification helpers by extracting the logic into testable patterns.

**Approach:** The notification helpers will be private methods on Orchestrator. To test them without starting the full daemon, create a minimal test harness:
- Instantiate `Orchestrator` (the constructor takes no args)
- Use `Object.assign` or type-cast to set `(orchestrator as any).ntfy` to a mock NtfyClient
- Use `Object.assign` or type-cast to set `(orchestrator as any).logger` to a real Logger
- Call the private methods via `(orchestrator as any).notifyTaskStart(task)` and `(orchestrator as any).notifyTaskEnd(task, result)`

Mock NtfyClient: Create a mock object `{ send: vi.fn().mockResolvedValue(undefined) }` -- do NOT use `vi.stubGlobal("fetch")` for these tests; mock at the NtfyClient level since we are testing the orchestrator's behavior, not NtfyClient's HTTP logic.

**Tests to add:**

**notifyTaskStart tests (NTFY-03):**
1. **fires when task.notify=true and ntfy configured** -- Set `ntfy` to mock, create task with `notify: true, category: "tests"`. Call `notifyTaskStart(task)`. Assert `mock.send` called once with message containing task name and category in body.
2. **does NOT fire when task.notify is false** -- Set `ntfy` to mock, task with `notify: false`. Call helper. Assert `mock.send` NOT called.
3. **does NOT fire when task.notify is undefined** -- Set `ntfy` to mock, task without `notify`. Assert `mock.send` NOT called.
4. **does NOT fire when ntfy is null** -- Set `ntfy` to `null`, task with `notify: true`. Assert no error thrown and no call made.
5. **includes category in body when present** -- Task with `category: "refactoring"`. Assert `mock.send` called with message where body contains "refactoring".
6. **handles missing category gracefully** -- Task with `notify: true` but no category. Assert `mock.send` called (notification still fires), body does not contain "undefined".

**notifyTaskEnd tests (NTFY-04, NTFY-05):**
7. **fires success notification with priority 3** -- Task with `notify: true`, result with `isError: false, totalCostUsd: 0.42, result: "Improved test coverage"`. Assert `mock.send` called with `priority: 3`, title containing task name, body containing cost and summary.
8. **fires failure notification with priority 4** -- Task with `notify: true`, result with `isError: true, result: "TypeError: cannot read..."`. Assert `mock.send` called with `priority: 4`, title containing "FAILED", body containing error snippet.
9. **does NOT fire when task.notify is false** -- Same guard as start.
10. **does NOT fire when ntfy is null** -- Same guard as start.
11. **truncates long result strings in body** -- Result with 500-char `result` string. Assert body is <= 200 chars (truncated).

**Helper for creating test tasks:**
```typescript
function makeTask(overrides?: Partial<NightShiftTask>): NightShiftTask {
  return {
    id: "ns-test001",
    name: "test-task",
    origin: "recurring",
    prompt: "do something",
    status: "running",
    timeout: "30m",
    createdAt: new Date().toISOString(),
    ...overrides,
  };
}
```

**Helper for creating test results:**
```typescript
function makeResult(overrides?: Partial<AgentExecutionResult>): AgentExecutionResult {
  return {
    sessionId: "sess-001",
    durationMs: 60000,
    totalCostUsd: 0.25,
    result: "Task completed successfully",
    isError: false,
    numTurns: 5,
    ...overrides,
  };
}
```

Run: `npm test -- tests/unit/orchestrator.test.ts -t "notification"` -- all MUST fail (RED).

Commit: `test(02-02): add failing tests for orchestrator notification hooks`
  </action>
  <verify>
    <automated>npm test -- tests/unit/orchestrator.test.ts -t "notification" 2>&1 | tail -5</automated>
    <manual>All 11 new tests fail because notifyTaskStart and notifyTaskEnd methods do not exist yet</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>11 test cases covering NTFY-03, NTFY-04, NTFY-05 guard conditions and message formatting, all failing</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement NtfyClient wiring and notification helpers in Orchestrator</name>
  <files>src/daemon/orchestrator.ts</files>
  <action>
**Add imports** at the top of orchestrator.ts:
```typescript
import { NtfyClient } from "../notifications/ntfy-client.js";
```
Add `AgentExecutionResult` to the existing type import from `../core/types.js`.

**Add private field** to the Orchestrator class:
```typescript
private ntfy: NtfyClient | null = null;
```
Place it alongside the existing `private beads: BeadsClient | null = null;`.

**Wire NtfyClient in `start()`** -- after `await ensureNightShiftDirs()` and before the logger.info("Daemon started") call:
```typescript
this.ntfy = this.config.ntfy ? new NtfyClient(this.config.ntfy) : null;
```

**Add `notifyTaskStart` private method:**
```typescript
private notifyTaskStart(task: NightShiftTask): void {
  if (!this.ntfy || !task.notify) return;
  const body = task.category
    ? `Category: ${task.category}`
    : "Running\u2026";
  void this.ntfy.send(
    {
      title: `Night-shift started: ${task.name}`,
      body,
      priority: 3,
    },
    this.logger,
  );
}
```

**Add `notifyTaskEnd` private method:**
```typescript
private notifyTaskEnd(task: NightShiftTask, result: AgentExecutionResult): void {
  if (!this.ntfy || !task.notify) return;
  const isFailure = result.isError;
  void this.ntfy.send(
    {
      title: isFailure
        ? `Night-shift FAILED: ${task.name}`
        : `Night-shift done: ${task.name}`,
      body: isFailure
        ? `Error: ${result.result.slice(0, 200)}`
        : `Cost: $${result.totalCostUsd.toFixed(2)} \u2014 ${result.result.slice(0, 200)}`,
      priority: isFailure ? 4 : 3,
    },
    this.logger,
  );
}
```

**Call notifyTaskStart in `tick()`** -- inside the dispatch loop, after `this.pool.dispatch(task)`:
```typescript
if (claimed) {
  this.pool.dispatch(task);
  this.notifyTaskStart(task);
}
```

**Call notifyTaskEnd in `handleCompleted()`** -- at the very end of the method, after updating stats:
```typescript
// Update stats
this.state.totalExecuted++;
this.state.totalCostUsd += result.totalCostUsd;

// Notify
this.notifyTaskEnd(task, result);
```

**Key constraints:**
- Use `void` prefix on `this.ntfy.send(...)` -- consistent with existing `void this.writeHeartbeat()` pattern in the codebase.
- Do NOT `await` the send calls -- fire-and-forget, must not block the poll loop.
- The `result.result.slice(0, 200)` truncation prevents oversized notification bodies.
- Priority 3 (default) for success, priority 4 (high) for failure -- per ntfy numeric scale and research recommendations.

Run all tests: `npm test -- tests/unit/orchestrator.test.ts --reporter=verbose` -- all must pass (GREEN).
Then run full suite: `npm test` -- no regressions.

Commit: `feat(02-02): wire NtfyClient into orchestrator with start/end notification hooks`
  </action>
  <verify>
    <automated>npm test -- tests/unit/orchestrator.test.ts --reporter=verbose 2>&1 | tail -25</automated>
    <manual>All orchestrator tests pass including the 11 new notification hook tests</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Orchestrator creates NtfyClient from config, fires start notifications on dispatch, fires end notifications on completion with correct priorities, guards on both ntfy config and task.notify, full test suite green</done>
</task>

</tasks>

<verification>
- `npm test -- tests/unit/orchestrator.test.ts --reporter=verbose` -- all tests pass
- `npm test -- tests/unit/scheduler.test.ts --reporter=verbose` -- all tests pass (no regressions from Plan 01)
- `npm run typecheck` -- no type errors
- `npm test` -- full suite green
</verification>

<success_criteria>
- NtfyClient instantiated once in start(), reused for all notifications
- notifyTaskStart fires for notify:true tasks with task name and category
- notifyTaskEnd fires with priority 3 on success (cost + summary) and priority 4 on failure (error snippet)
- Neither helper fires when ntfy is null or task.notify is falsy
- Notifications never block the poll loop (void prefix, no await)
- 11 new tests covering all NTFY-03, NTFY-04, NTFY-05 behaviors
</success_criteria>

<output>
After completion, create `.planning/phases/02-orchestrator-hooks/02-02-SUMMARY.md`
</output>
