---
phase: 04-git-harness-and-logging
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - src/agent/code-agent.ts
  - src/agent/bead-runner.ts
  - src/agent/prompts/log.md
  - tests/unit/code-agent.test.ts
autonomous: true
requirements:
  - AGENT-01
  - AGENT-02
  - AGENT-03
  - AGENT-04
  - LOG-01
  - LOG-02

must_haves:
  truths:
    - "runCodeAgent clones the repo, runs the pipeline, writes the JSONL log, runs the log bead, and cleans up in a finally block"
    - "Temp dirs (repoDir and handoffDir) are deleted unconditionally — even when the pipeline throws"
    - "JSONL log entry is written before cleanup, containing date, category, mr_url, cost_usd, duration_seconds, summary"
    - "Log bead is invoked with --mcp-config and Atlassian-only allowedTools when logMcpConfig is provided"
    - "Log bead failure is caught and logged — does not propagate or mask the pipeline result"
    - "Log bead is skipped (with warning log) when logMcpConfig is not configured"
    - "The log bead prompt instructs the agent to fetch the Confluence page, insert a newest-first row, and update without destroying existing content"
  artifacts:
    - path: "src/agent/code-agent.ts"
      provides: "Top-level runCodeAgent function wiring clone + pipeline + log + cleanup"
      exports: ["runCodeAgent"]
    - path: "src/agent/bead-runner.ts"
      provides: "Extended buildBeadArgs to accept optional mcpConfigPath and custom allowedTools"
      exports: ["buildBeadArgs", "buildBeadEnv", "runBead"]
    - path: "src/agent/prompts/log.md"
      provides: "Log bead prompt template for Confluence table update via MCP Atlassian"
    - path: "tests/unit/code-agent.test.ts"
      provides: "Unit tests for the full harness lifecycle"
  key_links:
    - from: "src/agent/code-agent.ts"
      to: "src/agent/git-harness.ts"
      via: "cloneRepo and cleanupDir calls"
      pattern: "cloneRepo|cleanupDir"
    - from: "src/agent/code-agent.ts"
      to: "src/agent/code-agent-runner.ts"
      via: "runCodeAgentPipeline call"
      pattern: "runCodeAgentPipeline"
    - from: "src/agent/code-agent.ts"
      to: "src/agent/run-logger.ts"
      via: "appendRunLog call"
      pattern: "appendRunLog"
    - from: "src/agent/code-agent.ts"
      to: "src/agent/bead-runner.ts"
      via: "runBead for log bead invocation"
      pattern: "runBead.*log"
---

<objective>
Create the top-level `runCodeAgent` harness that owns the full lifecycle (clone -> pipeline -> JSONL log -> Confluence log bead -> cleanup), the log bead prompt, and extend `bead-runner.ts` to support MCP config. Wire all Phase 4 pieces together.

Purpose: This is the capstone plan that connects AGENT-01/02/03/04 (git operations) with LOG-01 (JSONL) and LOG-02 (Confluence) into a single callable function. The agent clones, improves, logs, and cleans up — all unconditionally.
Output: `code-agent.ts` (top-level harness), `prompts/log.md`, updated `bead-runner.ts`, and unit tests.
</objective>

<execution_context>
@/Users/julienderay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julienderay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-git-harness-and-logging/04-RESEARCH.md
@.planning/phases/04-git-harness-and-logging/04-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Created by Plan 01. -->

From src/agent/git-harness.ts (created in Plan 01):
```typescript
export interface CloneResult {
  repoDir: string;
  handoffDir: string;
}
export async function cloneRepo(repoUrl: string, gitlabToken: string | undefined): Promise<CloneResult>;
export async function cleanupDir(dirPath: string): Promise<void>;
```

From src/agent/run-logger.ts (created in Plan 01):
```typescript
export interface RunLogEntry {
  date: string;
  category: string;
  mr_url: string | null;
  cost_usd: number;
  duration_seconds: number;
  summary: string;
}
export async function appendRunLog(entry: RunLogEntry, base?: string): Promise<void>;
```

From src/agent/code-agent-runner.ts (existing):
```typescript
export interface PipelineContext {
  config: CodeAgentConfig;
  configDir: string;
  repoDir: string;
  handoffDir: string;
  gitlabToken?: string;
  timeoutMs: number;
  logger: Logger;
}
export async function runCodeAgentPipeline(ctx: PipelineContext): Promise<CodeAgentRunResult>;
```

From src/agent/types.ts (existing):
```typescript
export type CodeAgentOutcome = "MR_CREATED" | "NO_IMPROVEMENT" | "ABANDONED";
export interface CodeAgentRunResult {
  outcome: CodeAgentOutcome;
  mrUrl?: string;
  categoryUsed: string;
  isFallback: boolean;
  reason?: string;
  summary?: string;
  totalCostUsd: number;
  totalDurationMs: number;
}
```

From src/agent/bead-runner.ts (existing — to be extended):
```typescript
export function buildBeadEnv(beadName: "analyze" | "implement" | "verify" | "mr", gitlabToken: string | undefined): NodeJS.ProcessEnv;
export function buildBeadArgs(prompt: string, model: string, maxTokens?: number): string[];
export async function runBead(options: { beadName, prompt, model, cwd, timeoutMs, gitlabToken?, maxTokens? }): Promise<BeadResult>;
```

From src/core/types.ts (extended in Plan 01):
```typescript
export interface CodeAgentConfig {
  // ... existing fields ...
  prompts: {
    analyze: string;
    implement: string;
    verify: string;
    mr: string;
    log: string;          // NEW: added in Plan 01
  };
  logMcpConfig?: string;  // NEW: added in Plan 01
}
```

From src/agent/prompt-loader.ts (existing):
```typescript
export async function loadBeadPrompt(templatePath: string, vars: Record<string, string>, configDir: string): Promise<string>;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Log bead prompt + extend bead-runner for MCP support</name>
  <files>
    src/agent/prompts/log.md
    src/agent/bead-runner.ts
  </files>
  <action>
**Create `src/agent/prompts/log.md`:**

Write the log bead prompt template. This bead uses MCP Atlassian tools to update a Confluence page with a new table row. The prompt must explicitly instruct the agent to preserve existing page content. Template variables: `{{date}}`, `{{category}}`, `{{mr_url}}`, `{{cost_usd}}`, `{{duration_seconds}}`, `{{summary}}`, `{{confluence_page_id}}`.

Content:

```markdown
## Context

You are the log bead of the night-shift code improvement agent.
A code improvement run just completed. Your single job is to record this run
in the team's Confluence log page by adding one new table row.

## Run Record

- Date: {{date}}
- Category: {{category}}
- MR URL: {{mr_url}}
- Cost: ${{cost_usd}}
- Duration: {{duration_seconds}}s
- Summary: {{summary}}

## Instructions

1. Call `mcp__atlassian__getAccessibleAtlassianResources` to discover the `cloudId`.
   Use the first result.

2. Call `mcp__atlassian__getConfluencePage` with:
   - `pageId`: `{{confluence_page_id}}`
   - `includeBody`: `true`

3. Locate the existing table in the page body. The table has these columns:
   **Date | Category | MR Link | Cost | Duration | Summary**

   If no table exists yet, create one with a header row.

4. Insert a new row at the TOP of the table body (immediately after the header row)
   so the newest entry appears first. Use these values:
   - Date: {{date}}
   - Category: {{category}}
   - MR Link: [View MR]({{mr_url}}) — or just "—" if the MR URL is "null" or empty
   - Cost: ${{cost_usd}}
   - Duration: {{duration_seconds}}s
   - Summary: {{summary}}

5. Call `mcp__atlassian__updateConfluencePage` with:
   - `pageId`: `{{confluence_page_id}}`
   - The full updated page body (including all existing content — do NOT delete anything)

## CRITICAL RULES

- Do NOT modify any content outside the table.
- Do NOT remove or reorder existing table rows.
- Do NOT replace the entire page body with just the table.
- Preserve all existing page content exactly as-is except for the single new row insertion.
- Use plain Markdown table syntax (pipe-delimited). No macros, no HTML.
```

**Extend `src/agent/bead-runner.ts`:**

1. Update `buildBeadEnv` type signature to accept `"analyze" | "implement" | "verify" | "mr" | "log"` for `beadName`. The `"log"` bead does NOT receive `GITLAB_TOKEN` — it only needs `HOME` and `PATH`.

2. Update `buildBeadArgs` signature to accept optional parameters for MCP config and custom allowed tools:
   ```typescript
   export function buildBeadArgs(
     prompt: string,
     model: string,
     maxTokens?: number,
     options?: {
       mcpConfigPath?: string;
       allowedTools?: string[];
     },
   ): string[];
   ```
   When `options.allowedTools` is provided, use it instead of the default `["Bash", "Read", "Write"]`.
   When `options.mcpConfigPath` is provided, add `"--mcp-config", mcpConfigPath` to the args array.

3. Update `runBead` options type to accept the new `beadName: "log"` variant, plus optional `mcpConfigPath` and `allowedTools`:
   ```typescript
   export async function runBead(options: {
     beadName: "analyze" | "implement" | "verify" | "mr" | "log";
     prompt: string;
     model: string;
     cwd: string;
     timeoutMs: number;
     gitlabToken?: string;
     maxTokens?: number;
     mcpConfigPath?: string;
     allowedTools?: string[];
   }): Promise<BeadResult>;
   ```
   Pass `options.mcpConfigPath` and `options.allowedTools` through to `buildBeadArgs`.

These are backward-compatible extensions — existing callers of `buildBeadArgs` and `runBead` don't need to change.

Verify: existing bead-runner tests still pass. Existing code-agent-runner tests still pass (they mock bead-runner anyway).
  </action>
  <verify>
    <automated>npx vitest run tests/unit/code-agent-runner.test.ts</automated>
  </verify>
  <done>
    Log bead prompt exists at src/agent/prompts/log.md with Confluence table update instructions. bead-runner.ts accepts "log" bead name, optional mcpConfigPath, and optional allowedTools. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Top-level runCodeAgent harness with tests</name>
  <files>
    src/agent/code-agent.ts
    tests/unit/code-agent.test.ts
  </files>
  <action>
**Create `src/agent/code-agent.ts`:**

This is the top-level function that owns the full lifecycle: clone -> pipeline -> JSONL log -> Confluence log bead -> cleanup.

```typescript
import { cloneRepo, cleanupDir } from "./git-harness.js";
import { runCodeAgentPipeline, type PipelineContext } from "./code-agent-runner.js";
import { appendRunLog, type RunLogEntry } from "./run-logger.js";
import { loadBeadPrompt } from "./prompt-loader.js";
import { runBead } from "./bead-runner.js";
import type { CodeAgentConfig } from "../core/types.js";
import type { CodeAgentRunResult } from "./types.js";
import type { Logger } from "../core/logger.js";

// Fixed 2-minute timeout for the log bead (per RESEARCH.md recommendation)
const LOG_BEAD_TIMEOUT_MS = 120_000;

// MCP Atlassian tools needed by the log bead
const LOG_BEAD_ALLOWED_TOOLS = [
  "mcp__atlassian__getAccessibleAtlassianResources",
  "mcp__atlassian__getConfluencePage",
  "mcp__atlassian__updateConfluencePage",
];

export async function runCodeAgent(
  config: CodeAgentConfig,
  configDir: string,
  options: {
    gitlabToken?: string;
    timeoutMs: number;
    logger: Logger;
    base?: string; // base dir for JSONL log path resolution
  },
): Promise<CodeAgentRunResult> {
  const { repoDir, handoffDir } = await cloneRepo(config.repoUrl, options.gitlabToken);

  try {
    const ctx: PipelineContext = {
      config,
      configDir,
      repoDir,
      handoffDir,
      gitlabToken: options.gitlabToken,
      timeoutMs: options.timeoutMs,
      logger: options.logger,
    };

    // Run the 4-bead pipeline (analyze -> implement -> verify -> mr)
    const result = await runCodeAgentPipeline(ctx);

    // LOG-01: Write local JSONL entry (harness-owned, not a bead)
    const logEntry: RunLogEntry = {
      date: new Date().toISOString(),
      category: result.categoryUsed,
      mr_url: result.mrUrl ?? null,
      cost_usd: result.totalCostUsd,
      duration_seconds: Math.round(result.totalDurationMs / 1000),
      summary: deriveSummary(result),
    };

    try {
      await appendRunLog(logEntry, options.base);
    } catch (err) {
      options.logger.error("Failed to write JSONL run log", {
        error: err instanceof Error ? err.message : String(err),
      });
    }

    // LOG-02: Confluence log bead (best-effort, errors logged but not propagated)
    if (config.logMcpConfig) {
      try {
        await runLogBead(ctx, result, config.logMcpConfig, logEntry);
      } catch (err) {
        options.logger.error("Log bead failed — Confluence not updated", {
          error: err instanceof Error ? err.message : String(err),
        });
      }
    } else {
      options.logger.warn("log_mcp_config not set — skipping Confluence update");
    }

    return result;
  } finally {
    // AGENT-02: Unconditional cleanup — even on crash or timeout
    await cleanupDir(repoDir);
    await cleanupDir(handoffDir);
  }
}

/**
 * Derives a short summary string from the pipeline result.
 *
 * For MR_CREATED: uses the MR URL or "MR created".
 * For NO_IMPROVEMENT: uses the reason.
 * For ABANDONED: uses "Abandoned after retries".
 */
function deriveSummary(result: CodeAgentRunResult): string {
  switch (result.outcome) {
    case "MR_CREATED":
      return result.mrUrl ?? "MR created";
    case "NO_IMPROVEMENT":
      return result.reason ?? "No improvement found";
    case "ABANDONED":
      return result.reason ?? "Abandoned after retries";
  }
}

/**
 * Runs the 5th "log" bead to update the Confluence page.
 *
 * LOG-02: The log bead is the only bead that receives --mcp-config.
 * It uses MCP Atlassian tools to fetch the page, insert a row, and update.
 * Runs regardless of pipeline outcome (even NO_IMPROVEMENT gets a row).
 */
async function runLogBead(
  ctx: PipelineContext,
  result: CodeAgentRunResult,
  mcpConfigPath: string,
  logEntry: RunLogEntry,
): Promise<void> {
  const vars: Record<string, string> = {
    date: logEntry.date,
    category: logEntry.category,
    mr_url: logEntry.mr_url ?? "null",
    cost_usd: logEntry.cost_usd.toFixed(4),
    duration_seconds: logEntry.duration_seconds.toString(),
    summary: logEntry.summary,
    confluence_page_id: ctx.config.confluencePageId,
  };

  const prompt = await loadBeadPrompt(ctx.config.prompts.log, vars, ctx.configDir);

  await runBead({
    beadName: "log",
    prompt,
    model: "claude-sonnet-4-6",
    cwd: ctx.repoDir,
    timeoutMs: LOG_BEAD_TIMEOUT_MS,
    mcpConfigPath,
    allowedTools: LOG_BEAD_ALLOWED_TOOLS,
    // No gitlabToken — log bead must not receive it
  });
}
```

**Create `tests/unit/code-agent.test.ts`:**

Mock all dependencies: `git-harness.js` (cloneRepo, cleanupDir), `code-agent-runner.js` (runCodeAgentPipeline), `run-logger.js` (appendRunLog), `bead-runner.js` (runBead), `prompt-loader.js` (loadBeadPrompt).

Test cases for `runCodeAgent`:

1. **Happy path**: cloneRepo -> runCodeAgentPipeline -> appendRunLog -> runLogBead -> cleanupDir. Verify all called in order.
2. **Cleanup on pipeline throw**: runCodeAgentPipeline throws -> cleanupDir still called for both repoDir and handoffDir. Verify the error propagates.
3. **JSONL log write failure**: appendRunLog throws -> error logged but pipeline result still returned. Log bead still runs.
4. **Log bead failure**: runBead for log throws -> error logged but pipeline result still returned. Cleanup still runs.
5. **No logMcpConfig**: config.logMcpConfig is undefined -> log bead NOT invoked, warning logged. JSONL still written.
6. **NO_IMPROVEMENT outcome**: Pipeline returns NO_IMPROVEMENT -> JSONL entry has mr_url=null and summary from reason.
7. **MR_CREATED outcome**: Pipeline returns MR_CREATED with mrUrl -> JSONL entry has mr_url set, log bead receives correct vars including confluence_page_id.
8. **Log bead receives MCP config**: When logMcpConfig is set, runBead is called with mcpConfigPath and the Atlassian allowedTools (not the default Bash/Read/Write).
9. **Log bead does NOT receive gitlabToken**: Verify the log bead runBead call has gitlabToken undefined.
10. **deriveSummary logic**: MR_CREATED uses mrUrl, NO_IMPROVEMENT uses reason, ABANDONED uses fallback text.

Use the same mock patterns as `code-agent-runner.test.ts` (vi.mock, vi.mocked, makeConfig helper, makeCtx-style setup).

Verify all tests pass, then commit: `feat(04-02): create runCodeAgent harness with log bead and full lifecycle tests`
  </action>
  <verify>
    <automated>npx vitest run tests/unit/code-agent.test.ts</automated>
  </verify>
  <done>
    runCodeAgent wires clone -> pipeline -> JSONL -> Confluence log bead -> cleanup. Cleanup is unconditional (finally block). Log bead uses --mcp-config with Atlassian-only tools. Log bead failure is caught and logged. JSONL always written. All 10+ tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run tests/unit/code-agent.test.ts` — all tests pass
2. `npx vitest run tests/unit/code-agent-runner.test.ts` — existing tests still pass (backward-compatible bead-runner changes)
3. `npx vitest run` — full test suite passes
4. `npx tsc --noEmit` — no TypeScript compilation errors
5. `src/agent/prompts/log.md` exists and contains Confluence table update instructions with {{confluence_page_id}} variable
</verification>

<success_criteria>
- runCodeAgent function exists and owns the full lifecycle: clone -> pipeline -> JSONL log -> log bead -> cleanup
- Cleanup runs unconditionally in finally block (AGENT-02)
- JSONL log written before cleanup with locked fields (LOG-01)
- Log bead invoked with --mcp-config and MCP Atlassian allowedTools when logMcpConfig is configured (LOG-02)
- Log bead prompt instructs agent to fetch page, prepend row, update without destroying content
- Log bead failure does not propagate (best-effort)
- All existing tests continue to pass
- Zero new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/04-git-harness-and-logging/04-02-SUMMARY.md`
</output>
