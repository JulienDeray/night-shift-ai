---
phase: 01-notification-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/notifications/ntfy-client.ts
  - tests/unit/ntfy-client.test.ts
autonomous: true
requirements:
  - NTFY-02

must_haves:
  truths:
    - "NtfyClient.send() fires an HTTP POST to base_url/topic with JSON body and does not throw on success"
    - "NtfyClient.send() catches network errors and logs at warn level without throwing"
    - "NtfyClient.send() catches HTTP 4xx/5xx responses and logs at warn level without throwing"
    - "NtfyClient.send() includes Authorization Bearer header when token is configured"
    - "NtfyClient.send() omits Authorization header when no token is configured"
    - "NtfyClient.send() maps NtfyMessage.body to the 'message' field in the JSON payload (ntfy API convention)"
    - "NtfyClient.send() uses a 5-second HTTP timeout via AbortSignal.timeout(5000)"
  artifacts:
    - path: "src/notifications/ntfy-client.ts"
      provides: "NtfyClient class and NtfyMessage interface"
      exports: ["NtfyClient", "NtfyMessage"]
      min_lines: 40
    - path: "tests/unit/ntfy-client.test.ts"
      provides: "Unit tests for NtfyClient"
      contains: "NtfyClient"
  key_links:
    - from: "src/notifications/ntfy-client.ts"
      to: "src/core/types.ts"
      via: "imports NtfyConfig for constructor parameter"
      pattern: "import.*NtfyConfig.*types"
    - from: "tests/unit/ntfy-client.test.ts"
      to: "src/notifications/ntfy-client.ts"
      via: "imports and tests NtfyClient"
      pattern: "import.*NtfyClient"
---

<objective>
Create the NtfyClient class that sends fire-and-forget push notifications to ntfy via HTTP POST.

Purpose: Provide a reusable notification sender that the orchestrator (Phase 2) will hold as an optional dependency. The client must never throw, never retry, and never block the daemon.

Output: NtfyClient class in src/notifications/ntfy-client.ts with NtfyMessage interface, and comprehensive unit tests.
</objective>

<execution_context>
@/Users/julienderay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julienderay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-notification-foundation/01-CONTEXT.md
@.planning/phases/01-notification-foundation/01-RESEARCH.md
@.planning/phases/01-notification-foundation/01-01-SUMMARY.md
@src/core/types.ts
@src/beads/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement NtfyClient class</name>
  <files>src/notifications/ntfy-client.ts</files>
  <action>
Create the directory `src/notifications/` and the file `src/notifications/ntfy-client.ts`.

Define the `NtfyAction` interface (for ntfy action buttons — typed for future use in Phase 2):
```typescript
export interface NtfyAction {
  action: "view" | "http" | "broadcast";
  label: string;
  url?: string;
  clear?: boolean;
}
```

Define the `NtfyMessage` interface:
```typescript
export interface NtfyMessage {
  title?: string;
  body?: string;        // maps to ntfy "message" field in JSON payload
  priority?: 1 | 2 | 3 | 4 | 5;
  tags?: string[];
  actions?: NtfyAction[];
}
```

Implement the `NtfyClient` class following the BeadsClient pattern (class with constructor, config stored as private fields):

```typescript
import type { NtfyConfig } from "../core/types.js";
import type { Logger } from "../core/logger.js";
```

Constructor:
- Takes `config: NtfyConfig`
- Stores `private readonly url: string` assembled as `${config.baseUrl}/${config.topic}` (strip trailing slash from baseUrl if present to avoid double-slash)
- Stores `private readonly token: string | undefined = config.token`

Method `send(message: NtfyMessage, logger: Logger): Promise<void>`:
- Wrap entire body in try/catch — catch block logs at `logger.warn("Ntfy notification error", { error: err instanceof Error ? err.message : String(err), url: this.url })` and returns void. NEVER throw.
- Build headers: `{ "Content-Type": "application/json" }`. If `this.token` is defined, add `"Authorization": "Bearer ${this.token}"`.
- Build JSON body: `{ title: message.title, message: message.body, priority: message.priority, tags: message.tags, actions: message.actions }`. Note: `message.body` maps to JSON field `"message"` (ntfy API convention).
- Call `fetch(this.url, { method: "POST", headers, body: JSON.stringify(payload), signal: AbortSignal.timeout(5000) })`.
- If `!response.ok`, log: `logger.warn("Ntfy notification failed", { status: response.status, url: this.url })`.
- If response is ok, optionally log at debug level: `logger.debug("Ntfy notification sent", { url: this.url })`. This is Claude's discretion — include it for observability.

Export both `NtfyClient` and `NtfyMessage` and `NtfyAction` as named exports.

CRITICAL: The JSON payload field is `"message"`, NOT `"body"`. NtfyMessage uses `body` as the property name for clarity, but the wire format must use `message`. Use `AbortSignal.timeout(5000)` for the 5-second timeout — no manual AbortController. Do NOT use a module-level fetch import — Node 22 has it as a global.
  </action>
  <verify>
    <automated>cd /Users/julienderay/code/night-shift && npx tsc --noEmit</automated>
    <manual>Verify src/notifications/ntfy-client.ts exists with NtfyClient class, NtfyMessage interface, and NtfyAction interface</manual>
  </verify>
  <done>NtfyClient class compiles. Constructor assembles URL from config. send() method makes HTTP POST with JSON body, uses AbortSignal.timeout(5000), catches all errors, logs at warn level, never throws.</done>
</task>

<task type="auto">
  <name>Task 2: Add NtfyClient unit tests</name>
  <files>tests/unit/ntfy-client.test.ts</files>
  <action>
Create `tests/unit/ntfy-client.test.ts` following the project test pattern.

Import `NtfyClient`, `NtfyMessage` from `../../src/notifications/ntfy-client.js`. Import `vi, describe, it, expect, beforeEach, afterEach` from `vitest`. Import `Logger` from `../../src/core/logger.js`.

Strategy: Use `vi.stubGlobal("fetch", mockFetch)` to mock the global `fetch` for controlled testing. Create a minimal logger by using `Logger.createCliLogger(false)` and spy on its `warn` method.

Tests to implement:

1. **"sends POST to assembled URL"** — Construct NtfyClient with `{ topic: "test-topic", baseUrl: "https://ntfy.example.com", token: undefined }`. Mock fetch to return `{ ok: true, status: 200 }`. Call `send({ title: "Hello", body: "World" }, logger)`. Assert fetch was called with `"https://ntfy.example.com/test-topic"` and method POST.

2. **"maps body to message field in JSON payload"** — Call send with `{ body: "test body" }`. Assert the fetch body (JSON.parse'd) has `message: "test body"` and does NOT have a `body` field.

3. **"includes all NtfyMessage fields in payload"** — Send with title, body, priority (3), tags (["tag1"]), actions. Assert JSON payload has `title`, `message`, `priority`, `tags`, `actions`.

4. **"includes Authorization header when token is set"** — Construct with `token: "tk_secret"`. Assert fetch was called with headers containing `Authorization: "Bearer tk_secret"`.

5. **"omits Authorization header when no token"** — Construct without token. Assert fetch headers do NOT contain `Authorization`.

6. **"does not throw on HTTP 4xx/5xx"** — Mock fetch to return `{ ok: false, status: 403 }`. Call send — assert it does NOT throw. Assert logger.warn was called with message containing "Ntfy notification failed".

7. **"does not throw on network error"** — Mock fetch to throw `new TypeError("fetch failed")`. Call send — assert it does NOT throw. Assert logger.warn was called with message containing "Ntfy notification error".

8. **"does not throw on timeout"** — Mock fetch to throw `new DOMException("signal timed out", "TimeoutError")`. Call send — assert it does NOT throw. Assert logger.warn was called.

9. **"strips trailing slash from baseUrl"** — Construct with `baseUrl: "https://ntfy.sh/"`. Assert fetch was called with `"https://ntfy.sh/test-topic"` (no double slash).

Use `afterEach(() => { vi.restoreAllMocks(); })` to clean up mocks between tests. Use `vi.spyOn(logger, "warn")` to verify warn calls.

For the fetch mock, create a helper:
```typescript
function mockFetchOk() {
  return vi.fn().mockResolvedValue({ ok: true, status: 200 });
}
```
  </action>
  <verify>
    <automated>cd /Users/julienderay/code/night-shift && npx vitest run tests/unit/ntfy-client.test.ts</automated>
  </verify>
  <done>All NtfyClient unit tests pass. URL assembly verified. JSON payload uses "message" not "body". Auth header included when token set, omitted when not. No exceptions thrown on 4xx, 5xx, network errors, or timeouts. Logger.warn called on all failure paths.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero TypeScript errors
2. `npx vitest run tests/unit/ntfy-client.test.ts` — all NtfyClient tests pass
3. `npx vitest run` — full test suite passes (no regressions from Plan 01)
</verification>

<success_criteria>
- NtfyClient exists at src/notifications/ntfy-client.ts
- NtfyClient.send() never throws under any circumstances (network error, timeout, 4xx, 5xx)
- NtfyClient.send() logs at warn level on failure
- NtfyClient.send() maps NtfyMessage.body to "message" in JSON payload
- NtfyClient.send() uses AbortSignal.timeout(5000) for 5-second timeout
- NtfyClient.send() includes Bearer token when configured
- All unit tests pass
- Full test suite has no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/01-notification-foundation/01-02-SUMMARY.md`
</output>
